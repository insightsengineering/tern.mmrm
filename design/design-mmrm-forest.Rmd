---
title: "Design for MMRM forest plot"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Objective

We would like to create a forest plot for the LS means estimated difference
at a specific visit (chosen by the user) across different subgroups created
by different baseline variables. This is FSTG03 "Forest Plot for Adjusted Means"
in the GDSR.

## Details

We will follow the FSTG01 layout example from GDSR, with the following
modifications:

- We note that only one MMRM is fitted and then the LS means are extracted
  from this single MMRM fit: "Calculate least squares means for each subgroup
  and estimate the mean difference (Treatment minus Control),
  including 95% confidence interval, from an MMRM analysis [...]"
- We replace the column heading "Subgroup" with "Baseline Risk Factor"
- We remove the "Category" column and display the Category headings directly
  underneath the Baseline Risk Factor heading, as in FSTG01.
- Also, we replace the first row heading, "Overall", with "All Patients",
  consistent with FSTG01.
- By default we present the following summary statistics:
  - total N
  - Control n and mean
  - Treatment n and mean
  - mean difference
  - 95% CI for mean difference
- By default plot using constant-sized symbols for the point estimates of the
  differences.  Proportionally sized symbols can be used optionally
  (e.g., size proportional to the total sample size for a subgroup).
- We also allow the option for presenting p-value for each mean difference to the
  right of the 95% CI.
  Note that this is not encouraged, as statistically it does not make
  a lot of sense in most situations - especially since the confidence intervals
  already show whether the p-value is below 5% or not.
- Note that we need exactly one treatment arm and one control arm selected for the
  forest plot. We might have more than one treatment arm in the original dataset
  and model fit. So we need to allow the user to select the treatment arm.

## Idea

We could maybe have a workflow as follows, where we try to stay close
to what we did for the survival and binary response forest plots:

```{r, eval = FALSE}
fit <- fit_mmrm(...)
subgroups <- extract_mmrm_subgroups(
  fit,
  visit = "VIS4",
  subgroups = c("AGEGRP", "REGION", "SEVERITY"),
  groups_lists = list(SEVERITY = list(
    "<= Q1" = c("Q0", "Q1"),
    "> Q1 to <= Q3" = c("Q2", "Q3"),
    "> Q3" = c("Q4", "Q5")
  )),
  weights = fit$weights,
  conf_level = fit$conf_level,
  label_all = "All Patients"
)
basic_table() %>%
  tabulate_mmrm_subgroups(
    subgroups,
    vars = c("n_tot", "n", "mean", "diff", "ci", "pval")
  )
```

Note:
- The `fit` already contains LS mean estimates, however we will need to derive new
  ones again for the subgroups.
- `visit` needs to reference one specific visit.
- We should save the `averages_emmeans` list in the object such that `visit` can
  reference this as a simple string without needing a list specification again.
- We should add the `weights_emmeans` chosen for LS means in the object. However
  it seems like we can only estimate proportional weights. So we might assert that.
- The subgroup variables already need to be factors.
- `groups_lists` helps to group factor levels further as needed (can also overlap).
- The tabulation function should then be relatively similar to the ones for survival
  and binary outcome.
- This must also work when the subgroup variables were not used as part of the
  covariates during the model fit.

# Prototypes

```{r}
mmrm_results <- fit_mmrm(
  vars = list(
    response = "FEV1",
    id = "USUBJID",
    arm = "ARMCD",
    visit = "AVISIT"
  ),
  data = mmrm_test_data,
  cor_struct = "unstructured",
  weights_emmeans = "equal",
  averages_emmeans = list(
    "VIS1+2" = c("VIS1", "VIS2")
  )
)
```

## Adjustments to `fit_mmrm`

See the code changes in this pull request.

## LS means computations

We will need to figure out here how to calculate the LS means for a specified
subgroup. Maybe we can use something along the lines of

```{r, eval = FALSE}
emmeans(fit, ..., specs = c(vars$visit, vars$arm), by = "subgroup_var") |>
  contrast(...)
```

One additional challenge is when an average of visits is requested instead of
a single visit.
Maybe the helper functions from `get_mmrm_lsmeans()` can be reused here.

Say we want to look
at the average `VIS1+2` and we want to use the following combination of factor
levels (which does not make sense of course):

```{r}
group_list <- list(
  "A" = c("Asian", "Black or African American"),
  "B" = c("Black or African American", "White")
)
```

Let's just look at each combination separately now, say we just look at `A`.
We start with the general grid object and then just subset. Then we just remove
the `RACE` variable again.

```{r}
emm_grid2 <- emmeans(
  fit,
  specs = c(vars$visit, vars$arm),
  weights = "proportional",
  data = mmrm_results$fit$data[1:10, ]
)
emm_grid2 <- subset(emm_grid2, RACE %in% group_list$A)
emm_grid3 <- emmeans(emm_grid2, specs = c(vars$visit, vars$arm))
emm_grid3
```

Note that in the last `emmeans()` step the `weights` argument does
not matter anymore.

So now we have the LS means by visit and treatment arm for this
specific subset of the data. What is left is just to apply the contrasting of the
single treatment arm (ensured upstream) and the control arm, as well as the
averaging of the relevant visits.

First we can subset further also for the visit variable.

```{r}
avgs <- attr(mmrm_results$lsmeans, "averages")["VIS1+2"]
emm_grid4 <- subset(emm_grid3, AVISIT %in% avgs[[1L]])
```

Now let's see if we can apply some of the existing helper functions to get the
results. For this we just need to wrap it in a similar way as what
`h_get_emmeans_res()` returns.

```{r}
emm_res <- list(
  object = emm_grid4,
  grid = emm_grid4@grid |> dplyr::rename(n = .wgt.) |> dplyr::mutate(n = as.integer(n))
)
```

Now we can start.

```{r}
avg_specs <- h_get_average_visit_specs(emm_res, vars = vars, averages = avgs)
avg_ests <- h_get_spec_visit_estimates(emm_res, avg_specs, mmrm_results$conf_level)
conts_specs <- h_single_visit_contrast_specs(emm_res, vars)
avg_conts_specs <- h_average_visit_contrast_specs(conts_specs, avgs)
avg_conts <- h_get_spec_visit_estimates(emm_res, avg_conts_specs, mmrm_results$conf_level, tests = TRUE)
```

So now we have everything we needed:

```{r}
avg_ests
avg_conts
```

One remaining question is how we can do the `subset()` operation in a function
where we specify the variable name as a string. We can go via the `data.frame`
detour:

```{r}
keep <- as.data.frame(emm_grid3)[["AVISIT"]] %in% avgs[[1L]]
emm_grid4_string <- subset(emm_grid3, keep)
identical(emm_grid4, emm_grid4_string)
```

## Extraction function

Now that we understand how to calculate the LS means we can write the extraction
function. We can look at the example `?extract_survival_subgroups` to see how
approximately the result should look like to fit into the workflow:

```{r}
# Testing dataset.
library(scda)
library(dplyr)
library(forcats)
library(rtables)

adtte <- synthetic_cdisc_data("latest")$adtte

# Save variable labels before data processing steps.
adtte_labels <- formatters::var_labels(adtte)

adtte_f <- adtte %>%
  filter(
    PARAMCD == "OS",
    ARM %in% c("B: Placebo", "A: Drug X"),
    SEX %in% c("M", "F")
  ) %>%
  mutate(
    # Reorder levels of ARM to display reference arm before treatment arm.
    ARM = droplevels(fct_relevel(ARM, "B: Placebo")),
    SEX = droplevels(SEX),
    AVALU = as.character(AVALU),
    is_event = CNSR == 0
  )
labels <- c(
  "ARM" = adtte_labels[["ARM"]],
  "SEX" = adtte_labels[["SEX"]],
  "AVALU" = adtte_labels[["AVALU"]],
  "is_event" = "Event Flag"
)
formatters::var_labels(adtte_f)[names(labels)] <- labels

df <- extract_survival_subgroups(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM", subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f
)
df
```

With that in mind we can prototype the function here.
We need a little helper function for the formatting.

```{r}
h_mmrm_subgroups_df <- function(estimates, contrasts, subgroup, var, label, vars) {
  is_all <- var == "ALL"
  row_type <- if (is_all) "content" else "analysis"
  list(
    estimates = data.frame(
      arm = estimates[[vars$arm]],
      n = estimates$n,
      lsmean = estimates$estimate,
      subgroup = subgroup,
      var = var,
      var_label = label,
      row_type = row_type
    ),
    contrasts = data.frame(
      n_tot = sum(estimates$n),
      diff = contrasts$estimate,
      lcl = contrasts$lower_cl,
      ucl = contrasts$upper_cl,
      pval = contrasts$p_value,
      subgroup = subgroup,
      var = var,
      var_label = label,
      row_type = row_type
    )
  )
}
```

Here it finally comes:

```{r}
#' @param fit (`tern_mmrm`)\cr model fit.
#' @param visit (`string`)\cr single visit or name of averages of visits (referring
#'   to the averages specified when creating the `fit`).
#' @param subgroups (`character` or `NULL`)\cr names of subgroup variables to use in the
#'   forest plot.
#' @inheritParams (named `list` of `list`)\cr optionally contains for each
#'   `subgroups` variable a list, which specifies the new group levels via the
#'   names and the levels that belong to it in the character vectors that
#'   are elements of the list.
#' @param treatment_arm (`string`)\cr single treatment arm to compare with the reference
#'   arm.
#' @param weights (`string`)\cr weights specification for the LS means.
#' @param conf_level (`proportion`)\cr confidence level for the LS mean differences.
#' @param label_all (`string`)\cr label for the total population analysis.
#'
#' @return A list with two elements:
#'   - `estimates`: `data.frame` with columns `arm`, `n`, `lsmean`, `subgroup`,
#'                  `var`, `var_label`, `row_type`.
#'   - `contrasts`: `data.frame` with columns `n_tot`, `diff`, `lcl`, `ucl`,
#'                  `pval`, `subgroup`, `var`, `var_label`, `row_type`. Note
#'                  that this has half the number of rows as `estimates`.
extract_mmrm_subgroups <- function(fit,
                                   visit,
                                   subgroups = NULL,
                                   groups_lists = list(),
                                   treatment_arm = fit$treatment_levels[1L],
                                   weights = fit$weights,
                                   conf_level = fit$conf_level,
                                   label_all = "All Patients") {
  # Assertions to be inserted in production.

  # Shortcuts.
  vars <- fit$vars
  ref_arm <- fit$ref_level
  lsm <- fit$lsmeans
  averages <- attr(lsm, "averages")
  is_average <- visit %in% names(averages)

  # Get overall result (all patients) - we have it already.

  # Estimates.
  est_overall <- lsm$estimates
  est_selected <- est_overall[[vars$visit]] == visit &
    est_overall[[vars$arm]] %in% c(ref_arm, treatment_arm)
  est_overall <- est_overall[est_selected, ]

  # Contrast.
  cont_overall <- lsm$contrasts
  cont_selected <- cont_overall[[vars$visit]] == visit &
    cont_overall[[vars$arm]] == treatment_arm
  cont_overall <- cont_overall[cont_selected, ]

  # Early return if there are no subgroup variables.
  result <- h_mmrm_subgroups_df(
    estimates = est_overall,
    contrasts = cont_overall,
    subgroup = label_all,
    var = "ALL",
    label = label_all,
    vars = vars
  )
  if (is.null(subgroups)) {
    return(result)
  }

  # Now loop over the subgroup variables to calculate subgroup results.
  subgroup_labels <- formatters::var_labels(fit$fit$data[subgroups], fill = TRUE)
  subgroup_results <- lapply(subgroups, function(this_var) {
    assert_factor(fit$fit$data[[this_var]])

    this_emm_grid <- emmeans(
      fit$fit,
      specs = c(vars$visit, vars$arm, this_var),
      weights = weights
    )
    this_emm_grid_df <- as.data.frame(this_emm_grid)
    this_groups_list <- if (!is.null(groups_lists[[this_var]])) {
      groups_lists[[this_var]]
    } else {
      tmp <- levels(this_emm_grid)[[this_var]]
      stats::setNames(as.list(tmp), tmp)
    }

    this_var_results <- list()
    for (this_group in names(this_groups_list)) {
      # Create the emm grid for this group.
      keep_visit <- if (is_average) {
        this_emm_grid_df[[vars$visit]] %in% averages[[visit]]
      } else {
        this_emm_grid_df[[vars$visit]] == visit
      }
      this_levels <- this_groups_list[[this_group]]
      keep_levels <- this_emm_grid_df[[this_var]] %in% this_levels
      keep_rows <- keep_visit & keep_levels
      emm_grid_for_group <- this_emm_grid[keep_rows]
      emm_grid_for_group <- emmeans(emm_grid_for_group, specs = c(vars$visit, vars$arm))

      # Derive the LS mean estimates and contrast.
      emm_res_for_group <- list(
        object = emm_grid_for_group,
        grid = emm_grid_for_group@grid |> dplyr::rename(n = .wgt.) |> dplyr::mutate(n = as.integer(n))
      )

      conts_specs <- h_single_visit_contrast_specs(emm_res_for_group, vars)
      group_res <-
        if (is_average) {
          avg_specs <- h_get_average_visit_specs(emm_res_for_group, vars = vars, averages = averages[visit])
          avg_conts_specs <- h_average_visit_contrast_specs(conts_specs, averages)
          list(
            estimates = h_get_spec_visit_estimates(emm_res_for_group, avg_specs, conf_level),
            contrasts = h_get_spec_visit_estimates(emm_res_for_group, avg_conts_specs, conf_level, tests = TRUE)
          )
        } else {
          list(
            estimates = h_get_single_visit_estimates(emm_res_for_group, conf_level),
            contrasts = h_get_spec_visit_estimates(emm_res_for_group, conts_specs, conf_level, tests = TRUE)
          )
        }
      this_var_results[[this_group]] <- h_mmrm_subgroups_df(
        group_res$estimates,
        group_res$contrasts,
        subgroup = this_group,
        var = this_var,
        label = unname(subgroup_labels[this_var]),
        vars = vars
      )
    }
    this_var_results
  })
  results <- c(
    result,
    unlist(subgroup_results, recursive = FALSE)
  )
  list(
    estimates = do.call(rbind, c(lapply(results, "[[", "estimates"), list(make.row.names = FALSE))),
    contrasts = do.call(rbind, c(lapply(results, "[[", "contrasts"), list(make.row.names = FALSE)))
  )
}
```

So let's try it out:

```{r}
df_mmrm <- extract_mmrm_subgroups(
  fit = mmrm_results,
  visit = "VIS1+2",
  subgroups = c("SEX", "RACE"),
  groups_lists = list(RACE = group_list)
)
df_mmrm
```

So we are not yet there, somehow we get the same results for the subgroups
and the contrasts are the same everywhere.

## Formatted analysis function

## Table creating function
