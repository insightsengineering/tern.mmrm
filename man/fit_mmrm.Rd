% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_mmrm.R
\name{fit_mmrm}
\alias{fit_mmrm}
\title{\code{MMRM} Analysis}
\usage{
fit_mmrm(
  vars = list(response = "AVAL", covariates = c(), id = "USUBJID", arm = "ARM", visit =
    "AVISIT"),
  data,
  conf_level = 0.95,
  cor_struct = "unstructured",
  weights_emmeans = "proportional",
  averages_emmeans = list(),
  optimizer = "automatic",
  parallel = FALSE,
  accept_singular = TRUE
)
}
\arguments{
\item{vars}{(named \code{list} of \code{string} or \code{character})\cr specifying the variables in the \code{MMRM}.
The following elements need to be included as character vectors and match corresponding columns
in \code{data}:
\itemize{
\item \code{response}: the response variable.
\item \code{covariates}: the additional covariate terms (might also include interactions).
\item \code{id}: the subject ID variable.
\item \code{arm}: the treatment group variable (factor).
\item \code{visit}: the visit variable (factor).
}

Note that the main effects and interaction of \code{arm} and \code{visit} are by default
included in the model.}

\item{data}{(\code{data.frame})\cr with all the variables specified in
\code{vars}. Records with missing values in any independent variables
will be excluded.}

\item{conf_level}{(\code{proportion})\cr confidence level of the interval.}

\item{cor_struct}{(\code{string})\cr specifying the covariance structure, defaults to
\code{"unstructured"}. See the details.}

\item{weights_emmeans}{(\code{string})\cr argument from \code{\link[emmeans:emmeans]{emmeans::emmeans()}}, \code{"proportional"} by default.}

\item{averages_emmeans}{(\code{list})\cr optional named list of visit levels which should be averaged
and reported along side the single visits.}

\item{optimizer}{(\code{string})\cr specifying the optimization algorithm which should be used. By default,
\code{"automatic"} will (if necessary) try all possible optimization algorithms and choose the best result.
If another algorithm is chosen and does not give a valid result, an error will occur.}

\item{parallel}{(\code{flag})\cr controls whether \code{"automatic"} optimizer search can use available free cores on the
machine (not default).}

\item{accept_singular}{(\code{flag})\cr whether singular design matrices are reduced
to full rank automatically and additional coefficient estimates will be missing.}
}
\value{
A \code{tern_mmrm} object which is a list with MMRM results:
\itemize{
\item \code{fit}: The \code{mmrm} object which was fitted to the data. Note that the attribute \code{optimizer}
contains the finally used optimization algorithm, which can be useful for refitting the model
later on.
\item \code{cov_estimate}: The matrix with the covariance matrix estimate.
\item \code{diagnostics}: A list with model diagnostic statistics (REML criterion, AIC, corrected AIC, BIC).
\item \code{lsmeans}: This is a list with data frames \code{estimates} and \code{contrasts}.
The attributes \code{averages} and \code{weights} save the settings used
(\code{averages_emmeans} and \code{weights_emmeans}).
\item \code{vars}: The variable list.
\item \code{labels}: Corresponding list with variable labels extracted from \code{data}.
\item \code{ref_level}: The reference level for the arm variable, which is always the first level.
\item \code{conf_level}: The confidence level which was used to construct the \code{lsmeans} confidence intervals.
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}

Does the \code{MMRM} analysis. Multiple other functions can be called on the result to produce
tables and graphs.
}
\details{
Only Satterthwaite adjusted degrees of freedom (d.f.) are supported, and they numerically
match the results obtained in SAS.

For the covariance structure (\code{cor_struct}), the user can choose among the following options.
\itemize{
\item \code{unstructured}: Unstructured covariance matrix. This is the most flexible choice and default.
If there are \code{T} visits, then \code{T * (T+1) / 2} variance parameters are used.
\item \code{toeplitz}: Homogeneous Toeplitz covariance matrix, which uses \code{T} variance parameters.
\item \verb{heterogeneous toeplitz}: Heterogeneous Toeplitz covariance matrix,
which uses \code{2 * T - 1} variance parameters.
\item \verb{heterogeneous ante-dependence}: Heterogeneous Ante-Dependence covariance matrix,
which uses \code{2 * T - 1} variance parameters.
\item \verb{heterogeneous auto-regressive}: Heterogeneous Auto-Regressive (order 1) covariance matrix,
which uses \code{T + 1} variance parameters.
\item \code{auto-regressive}: Homogeneous Auto-Regressive (order 1) covariance matrix,
which uses 2 variance parameters.
\item \verb{heterogeneous compound symmetry}: Heterogeneous Compound Symmetry covariance matrix, which uses
\code{T + 1} variance parameters.
\item \verb{compound symmetry}: Homogeneous Compound Symmetry covariance matrix, which uses 2
variance parameters.
}

For the \code{optimizer}, the user can choose among alternatives to the recommended \code{"automatic"},
please see \code{\link[mmrm:refit_multiple_optimizers]{mmrm::refit_multiple_optimizers()}} for details. Usually it should not be necessary
to use a specific optimizer and the \code{"automatic"} setting should be kept.
}
\examples{
library(dplyr)
library(rtables)

mmrm_results <- fit_mmrm(
  vars = list(
    response = "FEV1",
    covariates = c("RACE", "SEX"),
    id = "USUBJID",
    arm = "ARMCD",
    visit = "AVISIT"
  ),
  data = mmrm_test_data,
  cor_struct = "unstructured",
  weights_emmeans = "equal",
  averages_emmeans = list(
    "VIS1+2" = c("VIS1", "VIS2")
  )
)

}
